#LyX 2.0 created this file. For more info see http://www.lyx.org/
\lyxformat 413
\begin_document
\begin_header
\textclass article
\use_default_options true
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding auto
\fontencoding global
\font_roman lmodern
\font_sans lmss
\font_typewriter default
\font_default_family sfdefault
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100

\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing single
\use_hyperref false
\papersize a4paper
\use_geometry true
\use_amsmath 1
\use_esint 1
\use_mhchem 1
\use_mathdots 1
\cite_engine natbib_authoryear
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\use_refstyle 1
\index Index
\shortcut idx
\color #008000
\end_index
\leftmargin 3.25cm
\rightmargin 3.25cm
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Title
Design and Implementation of an Asynchronous TDMA Network-on-Chip
\end_layout

\begin_layout Author
Rasmus Bo Sørensen 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
and
\end_layout

\end_inset

 Mark Ruvald Pedersen 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
and
\end_layout

\end_inset

 Madava Dilshan Vithanage
\end_layout

\begin_layout Section
Introduction
\begin_inset Marginal
status open

\begin_layout Plain Layout
Rasmus
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The trend in most kinds of computing goes towards Chip Multi Processing
 (CMP).
 As on-Chip systems scale, the need for high bandwidth in the interconnect
 between processing units become higher than ever before.
 Making the traffic in the interconnect packet-based enables many packets
 to be routed in the interconnect simultaniously, resulting in a high bandwidth
 compared to a traditional bus.
 A Network-on-Chip (NoC) is a packet-based interconnect that scales very
 well with the number of resources in the system.
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
When facing thousands of cores on a single chip in near future, the interconnect
ion network becomes a vital part of any design.
 The cost of such a network should be low in coomparison to the cores, scale
 linearly with number of cores, and allow as much concurrent (contention-free)
 communcation as possible.
 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
As chips become larger the difficulties of routing one global clock to the
 whole chip (with an acceptable skew) makes it infeasible to have a global
 clock.
 Getting rid of the global clock is a tremendous advantage, especialy compare
 to power usage.
 Designing an Asynchronous NoC would solve the problem of bandwidth and
 the problem of routing one global clock.
\end_layout

\begin_layout Standard
In this report we will design and implement an Asynchronous TDMA Network-on-Chip
 similar to the Æthereal
\end_layout

\begin_layout Section
Design and Implementation
\end_layout

\begin_layout Subsection
Asynchronous TDMA Network-on-Chip
\begin_inset Marginal
status open

\begin_layout Plain Layout
Rasmus
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Time Division Multiple Access (TDMA)
\end_layout

\begin_layout Itemize
Each link is divided in time into a number of time slots.
\end_layout

\begin_layout Itemize
The routing is determined statically
\end_layout

\begin_layout Standard
Time slotting, statically scheduled
\end_layout

\begin_layout Standard
Synchronization to keep global notion of time
\end_layout

\begin_layout Standard
Elastic synchronozation
\end_layout

\begin_layout Subsection
\begin_inset CommandInset label
LatexCommand label
name "sub:Protocol"

\end_inset

Protocol
\begin_inset Marginal
status open

\begin_layout Plain Layout
Mark
\begin_inset Note Note
status open

\begin_layout Plain Layout
Or madava?
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Packet consists of flits (phit == flit)
\end_layout

\begin_layout Standard
Statically source-routed (ie.
 destination determined by sender-resource not individual switches)
\end_layout

\begin_layout Standard
First flit of packet is called the 
\emph on
header
\emph default
.
 The header is a special flit since it contains the full route.
 Bottom 2 LSbs of header determines the next hop
\begin_inset Note Note
status open

\begin_layout Plain Layout
better word than 
\begin_inset Quotes eld
\end_inset

hop
\begin_inset Quotes erd
\end_inset

?
\end_layout

\end_inset

.
 Shifted header + remaining flits of packet is routed to this next hop.
\end_layout

\begin_layout Standard
Maximum of (34-2)/2=16 hops can be encoded in the header.
 If the mesh is to be square and any resource should be able to communicte
 any other resource, this 16 hop limit, restricts us to 
\begin_inset Formula $9\times9$
\end_inset

 meshes
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
\begin_inset Formula $2(n-1)=16\iff n=9$
\end_inset

.
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
Header, body, empty space grey encoding.
 Packets must not have empty-spaces between flits; ie.
 a packets are delimited by headers and empty-spaces.
\end_layout

\begin_layout Subsection
Switch
\end_layout

\begin_layout Standard
Our switch consists of an routing unit (HPU) followed by a crossbar.
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
Insert overall block diagram of switch - similar to the phillips paper
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
HPU
\begin_inset Marginal
status open

\begin_layout Plain Layout
Mark
\end_layout

\end_inset


\end_layout

\begin_layout Standard
As mentioned in the protocol description, the entire route is contained
 in the header.
 All flits of the packet should be routed as specified by the next-hop field
 in the header.
 Hence the routing-logic has to:
\end_layout

\begin_layout Enumerate
Identify the header.
\end_layout

\begin_layout Enumerate
If a header is found:
\end_layout

\begin_deeper
\begin_layout Enumerate
Parse the header -- setting the crossbar according to next-hop field,
\end_layout

\begin_layout Enumerate
Update the route such that the next-next-hop will become the next-hop at
 the next switch.
\end_layout

\end_deeper
\begin_layout Enumerate
Keep crossbar-settings for all flits of the packet.
\end_layout

\begin_deeper
\begin_layout Enumerate
Reset settings upon recieving an empty-space.
\end_layout

\end_deeper
\begin_layout Enumerate
Leave non-header flits unaltered.
\end_layout

\begin_layout Standard
Since we assign special meaning to the header of each packet, our protocol
 is stateful.
 This makes the 
\emph on
header-parsing unit
\emph default
 the most complex part of our switch.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename Figures/hpu_top.pdf
	width 10cm

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:HPU"

\end_inset

Simplified Header-parsing unit.
 Resetting by empty-spaces not shown.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
The HPU speculatively computes the one-hot decoded 
\begin_inset Formula $select$
\end_inset

 signal for use in the crossbar-stage.
 When it has been determined that the flit is a header, 
\begin_inset Formula $select$
\end_inset

 is latched forward to the crossbar-stage.
 
\end_layout

\begin_layout Standard
Since the select latch is a simple latch, not a token-latch, we should be
 careful to not accidentally opening it.
\end_layout

\begin_layout Standard
Assume early scheme 
\end_layout

\begin_layout Standard
sel should be set before the processed flit is latched into the token-latch.
\end_layout

\begin_layout Subsubsection
Crossbar
\begin_inset Marginal
status open

\begin_layout Plain Layout
Rasmus
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Fully generic, can be instansiated with any number of in- and output ports.
\end_layout

\begin_layout Standard
One hot encoded select signal for demuxes.
\end_layout

\begin_layout Standard
Logic depth is 2 logic gates.
\end_layout

\begin_layout Subsubsection
Latches
\begin_inset Marginal
status open

\begin_layout Plain Layout
Mark
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Testbench
\begin_inset Marginal
status open

\begin_layout Plain Layout
Madava
\end_layout

\end_inset


\end_layout

\begin_layout Section
Performance
\begin_inset Marginal
status open

\begin_layout Plain Layout
Rasmus
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Heatmap, what is it good for, what can it show? Experiments to finde performance
 characteristics, which values have we measured? Compared to synchronous
 performance
\end_layout

\begin_layout Section
Discussion
\end_layout

\begin_layout Standard
The asynchronous fibonaci circuit can run in an FPGA, this shows the basic
 primetives work (Latches, C-elements, ...) The only thing preventing our NoC
 from runing an an FPGA is the matched delays.
\end_layout

\begin_layout Section
Conclusion
\end_layout

\end_body
\end_document
