#LyX 2.0 created this file. For more info see http://www.lyx.org/
\lyxformat 413
\begin_document
\begin_header
\textclass article
\begin_preamble
\usepackage{bytefield}

\usepackage{tikz-timing}


%\usepackage{tikz}
\end_preamble
\use_default_options true
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding auto
\fontencoding global
\font_roman lmodern
\font_sans lmss
\font_typewriter default
\font_default_family sfdefault
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100

\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing single
\use_hyperref true
\pdf_title "Design and Implementation of an Asynchronous TDMA"
\pdf_author "Rasmus Bo Sørensen, Mark Ruvald Pedersen, Madava Dilshan Vithanage"
\pdf_subject "Asynchronous NoC"
\pdf_keywords "02204, Asynchronous, NoC"
\pdf_bookmarks true
\pdf_bookmarksnumbered false
\pdf_bookmarksopen false
\pdf_bookmarksopenlevel 1
\pdf_breaklinks false
\pdf_pdfborder false
\pdf_colorlinks true
\pdf_backref section
\pdf_pdfusetitle true
\papersize a4paper
\use_geometry true
\use_amsmath 1
\use_esint 1
\use_mhchem 1
\use_mathdots 1
\cite_engine natbib_authoryear
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\use_refstyle 1
\index Index
\shortcut idx
\color #008000
\end_index
\leftmargin 3.25cm
\rightmargin 3.25cm
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Title
Design and Implementation of an Asynchronous TDMA Network-on-Chip
\end_layout

\begin_layout Author
Rasmus Bo Sørensen 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
and
\end_layout

\end_inset

 Mark Ruvald Pedersen 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
and
\end_layout

\end_inset

 Madava Dilshan Vithanage
\end_layout

\begin_layout Abstract
We have designed and implemented an asynchronous TDMA Network-on-Chip on
 the basis of the Æthereal Network-on-Chip.
 The Æthereal Network-on-Chip was initially designed by Philips.
 We have analyzed the elasticity of our implementation and seen that the
 bandwidth of the network recovers after an increased delay on a link.
 The network is elastic in the sens that it can absorb phase differences
 in the network, without lowering the bandwidth of the network.
\end_layout

\begin_layout Section
Introduction
\begin_inset Marginal
status open

\begin_layout Plain Layout
Rasmus
\end_layout

\end_inset


\end_layout

\begin_layout Standard
When facing hundreds of cores on a single chip in the near future, the interconn
ection network becomes an even more important part of any design.
 The cost of such a network should be low in comparison to the cores, scale
 linearly with number of cores, and allow as much concurrent (contention-free)
 communication as possible.
 Making the traffic in the interconnect packet-based enables many packets
 to be routed in the interconnect simultaneously.
 A Network-on-Chip (NoC) is a packet-based interconnect that scales very
 well with the number of resources in the system.
\end_layout

\begin_layout Standard
As chips become larger the difficulties of routing one global clock to the
 whole chip (with an acceptable skew) makes it infeasible to have a global
 clock.
 Avoiding the global clock is a tremendous advantage, especially compared
 to power usage.
 Designing an Asynchronous NoC would solve the problem of bandwidth and
 the problem of routing one global clock.
 Our main design goal has been to minimize the switch complexity, at a cost
 of NI complexity.
\end_layout

\begin_layout Section
Design and Implementation
\end_layout

\begin_layout Subsection
Asynchronous TDMA Network-on-Chip
\begin_inset Marginal
status open

\begin_layout Plain Layout
Rasmus
\end_layout

\end_inset


\end_layout

\begin_layout Standard
We will design and implement an asynchronous TDMA Network-on-Chip, on the
 basis of the Æthereal NoC, designed by Philips.
 TDMA stands for Time Division Multiple Access, which means the communication
 resources are divided in time and split into sections allowing multiple
 data units to be routed simultaneously.
\end_layout

\begin_layout Standard
The Æthereal NoC is a statically scheduled NoC, where a compile-time schedule
 has been made that ensures no two data units are routed on the same link
 at once.
 With this static scheduling, bandwidth between resources is known at compile-ti
me and this network is therefore well suited for hard real-time systems.
\end_layout

\begin_layout Standard
Dividing communication resources into time slots, require synchronization
 of these resources, to make sure that no time slots are dropped.
 In a synchronous NoC this synchronization is easily derived from the global
 clock.
 In our asynchronous implementation the synchronization is done by waiting
 for data units on all inputs of a node to be present, before routing them
 through the switch, ensuring that no data units are dropped and that the
 time slots are transmitted in order.
 This synchronization does not mean that all links at all time will be transmitt
ing the same time slot, but it means that each switch transmit the same
 time slot at once.
 Asynchronous circuits are elastic with respect to timing.
 In our NoC the elasticity means that constant phase differences between
 the transmission of flits in two neighboring switches as well as minor
 fluctuation in the propagation delays of links, can be absorbed by the
 network.
\end_layout

\begin_layout Subsection
\begin_inset CommandInset label
LatexCommand label
name "sub:Protocol"

\end_inset

Protocol
\begin_inset Marginal
status open

\begin_layout Plain Layout
Mark
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Our protocol is simplistic: Packets are statically source-routed using cut-throu
gh routing, with 1
\begin_inset space ~
\end_inset

flit being equal to 1
\begin_inset space ~
\end_inset

phit.
 Packets can however consist of an arbitrary number of flits.
 Delimitation of packets is indicated by the 
\emph on
Start-Of-Packet
\emph default
 (SOP) and 
\emph on
End-Of-Packet
\emph default
 (EOP) bit fields, as shown in figure
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "fig:flit_format"

\end_inset

.
 
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{centering}
\end_layout

\begin_layout Plain Layout


\backslash
begin{bytefield}{34}
\end_layout

\begin_layout Plain Layout

   
\backslash
bitheader[b]{0-33} 
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

   
\backslash
bitbox{1}{
\backslash
rotatebox{90}{
\backslash
tiny SOP}} &
\end_layout

\begin_layout Plain Layout

   
\backslash
bitbox{1}{
\backslash
rotatebox{90}{
\backslash
tiny EOP}} &
\end_layout

\begin_layout Plain Layout

   
\backslash
bitbox{32}{Payload/route}
\end_layout

\begin_layout Plain Layout

 
\backslash
end{bytefield}
\end_layout

\begin_layout Plain Layout


\backslash
par
\backslash
end{centering}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:flit_format"

\end_inset

General format of all flits.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
SOP and EOP are used to encode four types of flits (SOP,EOP):
\end_layout

\begin_layout Description
(0,0)
\begin_inset space ~
\end_inset

Empty
\begin_inset space ~
\end_inset

space: Not a real flit, since empty spaces are not part of a packet.
 An empty-space is a valid token, which is sent when no other data is to
 be transmitted on a token-channel.
 The existence of empty-spaces is required since all input channels of the
 switch must provide tokens before any of them can be processed.
 
\end_layout

\begin_layout Description
(1,0)
\begin_inset space ~
\end_inset

Header: Holds the route.
 The route is a sequence of directions that the entire packet should follow.
\end_layout

\begin_layout Description
(1,1)
\begin_inset space ~
\end_inset

Body: Holds the actual payload data that is to be delivered to destination
 resource.
\end_layout

\begin_layout Description
(0,1)
\begin_inset space ~
\end_inset

End
\begin_inset space ~
\end_inset

body: Holds payload data - like a body-flit - but also signifies the last
 flit of packet.
 
\end_layout

\begin_layout Standard
Hence packets always begin with a header, followed by zero or more bodies
 and end with an end-body.
 There may be zero or more empty-spaces in between packets.
 Figure
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "fig:packet_timing"

\end_inset

 shows how SOP and EOP are grey encoded as a packet is sent.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement h
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename Figures/packet_timing.pdf
	scale 110

\end_inset


\begin_inset Note Note
status open

\begin_layout Plain Layout
Original tikz: 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
begin{centering}
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

 
\backslash
begin{tikztimingtable}[xscale=1, yscale=1, semithick] 
\end_layout

\begin_layout Plain Layout

     
\backslash
normalsize{SOP}      & L HHH HHH HHH LLL LLL  
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

     
\backslash
normalsize{EOP}      & L LLL HHH HHH HHH LLL 
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

     
\backslash
phantom{
\backslash
normalsize{Data}}      &   
\backslash

\backslash

\end_layout

\begin_layout Plain Layout


\backslash
end{tikztimingtable}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

 
\backslash
begin{tikztimingtable}[xscale=1, yscale=2, semithick] 
\end_layout

\begin_layout Plain Layout

   
\backslash
normalsize{Data} & T 
\end_layout

\begin_layout Plain Layout

3D{$
\backslash
begin{array}{c} 
\backslash
mbox{
\backslash
fontsize{10}{2}
\backslash
selectfont 
\backslash
raisebox{-0.7ex}{Start}} 
\backslash

\backslash
 
\backslash
mbox{
\backslash
fontsize{10}{2}
\backslash
selectfont header} 
\backslash
end{array}$} 
\end_layout

\begin_layout Plain Layout

3D{Body} 
\end_layout

\begin_layout Plain Layout

3D{Body} 
\end_layout

\begin_layout Plain Layout

3D{$
\backslash
begin{array}{c} 
\backslash
mbox{
\backslash
fontsize{10}{2}
\backslash
selectfont 
\backslash
raisebox{-0.7ex}{End}} 
\backslash

\backslash
 
\backslash
mbox{
\backslash
fontsize{10}{2}
\backslash
selectfont body} 
\backslash
end{array}$}  
\end_layout

\begin_layout Plain Layout

3L{$
\backslash
begin{array}{c} 
\backslash
mbox{
\backslash
fontsize{10}{2}
\backslash
selectfont 
\backslash
raisebox{-0.7ex}{Empty}} 
\backslash

\backslash
 
\backslash
mbox{
\backslash
fontsize{10}{2}
\backslash
selectfont space} 
\backslash
end{array}$} 
\backslash

\backslash

\end_layout

\begin_layout Plain Layout


\backslash
extracode
\end_layout

\begin_layout Plain Layout

 
\backslash
begin{pgfonlayer}{background}
\end_layout

\begin_layout Plain Layout

 
\backslash
node [anchor=south east] at (16.3, 0.2) {
\backslash
fontsize{6}{2}
\backslash
selectfont Empty};
\end_layout

\begin_layout Plain Layout

 
\backslash
node [anchor=south east] at (16.2, -0.2) {
\backslash
fontsize{6}{2}
\backslash
selectfont space};
\end_layout

\begin_layout Plain Layout


\backslash
end{pgfonlayer}
\end_layout

\begin_layout Plain Layout

 
\backslash
end{tikztimingtable}
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout


\backslash
par
\backslash
end{centering}
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:packet_timing"

\end_inset

Example of timing diagram of a packet with 4 flits, 3 of which carry payload.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Since we are using cut-through source-routing, it is only possible to store
 the route in the first few flits of a packet -- the header.
 In our case the header is only 1
\begin_inset space ~
\end_inset

flit long, and contains the full remaining route: It contains only what
 
\emph on
remains
\emph default
 of the route, since previous routing-directions are shifted out for each
 hop made.
 This is further explained in section
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "sub:HPU"

\end_inset

.
 As we will see later, this allows for simple routing-decision logic since
 the destination-port is always specified by the two least significant bits.
 
\end_layout

\begin_layout Standard
Since a flit is 34
\begin_inset space \thinspace{}
\end_inset

bits, 2 of which is always spent on SOP and EOP, this leaves 32
\begin_inset space \thinspace{}
\end_inset

bits to the route.
 With each route entry being 2
\begin_inset space \thinspace{}
\end_inset

bits, a maximum of 16
\begin_inset space \thinspace{}
\end_inset

hops can be encoded in the header.
 However, as will be explained in section
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "sub:HPU"

\end_inset

, the last entry has to be of opposite direction than the second-last entry.
 Hence only 15
\begin_inset space \thinspace{}
\end_inset

hops can effectively be encoded in the header.
 If we consider a rectangular 
\begin_inset Formula $N\times M$
\end_inset

 mesh, then the diameter of this graph in terms of hops is 
\begin_inset Formula $N+M-2$
\end_inset

.
 Thus if any node should be able to communicate any other resource, we must
 obey 
\begin_inset Formula $N+M-2=15$
\end_inset

.
 This allows for the different configurations: 
\begin_inset Formula $\{M,N\}\in\left\{ \{1,16\},\,\{2,15\},\,\ldots,\{7,10\},\,\{8,9\}\right\} $
\end_inset

.
\end_layout

\begin_layout Standard
To increase the amount
\end_layout

\begin_layout Subsection
Switch
\end_layout

\begin_layout Standard
A main component of the NoC is the switch.
 We have chosen to implement a 2D switch with five ports, where the indices
 0 to 4 represent the north, east, south, west, and the resource ports respectiv
ely.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename Figures/switch.pdf

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:Switch"

\end_inset

Switch
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename Figures/switch_top.pdf
	scale 50
	rotateOrigin center

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:Top-level-Block-Diagram"

\end_inset

Top-level Block Diagram of the Switch
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Internal structure: Our switch consists of an routing unit (HPU) followed
 by a crossbar.
\end_layout

\begin_layout Standard
Idealized symbol of switch.
 
\end_layout

\begin_layout Standard
Port indices for N,S,E,W,R
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
Insert overall block diagram of switch - similar to the phillips paper
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
\begin_inset CommandInset label
LatexCommand label
name "sub:HPU"

\end_inset

HPU
\begin_inset Marginal
status open

\begin_layout Plain Layout
Mark
\end_layout

\end_inset


\end_layout

\begin_layout Standard
As mentioned in the protocol description, the entire route is contained
 in the header.
 All flits of the packet should be routed as specified by the next-hop field
 in the header.
 Hence the routing-logic has to:
\end_layout

\begin_layout Enumerate
Identify the header.
\end_layout

\begin_layout Enumerate
If a header is found:
\end_layout

\begin_deeper
\begin_layout Enumerate
Parse the header -- setting the crossbar according to next-hop field,
\end_layout

\begin_layout Enumerate
Update the route such that the next-next-hop will become the next-hop at
 the next switch.
\end_layout

\end_deeper
\begin_layout Enumerate
Keep crossbar-settings for all flits of the packet.
\end_layout

\begin_deeper
\begin_layout Enumerate
Reset settings upon receiving an empty-space.
\end_layout

\end_deeper
\begin_layout Enumerate
Leave non-header flits unaltered.
\end_layout

\begin_layout Standard
Since we assign special meaning to the header of each packet, our protocol
 is stateful.
 This makes the 
\emph on
header-parsing unit
\emph default
 the most complex part of our switch.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement h
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Float figure
placement H
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{centering}
\end_layout

\begin_layout Plain Layout


\backslash
begin{bytefield}{34}
\end_layout

\begin_layout Plain Layout

   
\backslash
bitheader[b]{0-33} 
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

   
\backslash
bitbox{1}{1} 
\end_layout

\begin_layout Plain Layout

   
\backslash
bitbox{1}{0} 
\end_layout

\begin_layout Plain Layout


\backslash
bitbox{2}{
\backslash
color{lightgray}
\backslash
rule{
\backslash
width}{
\backslash
height}} 
\end_layout

\begin_layout Plain Layout


\backslash
bitbox{2}{
\backslash
color{lightgray}
\backslash
rule{
\backslash
width}{
\backslash
height}} 
\end_layout

\begin_layout Plain Layout


\backslash
bitbox{2}{
\backslash
color{lightgray}
\backslash
rule{
\backslash
width}{
\backslash
height}} 
\end_layout

\begin_layout Plain Layout


\backslash
bitbox{2}{
\backslash
color{lightgray}
\backslash
rule{
\backslash
width}{
\backslash
height}} 
\end_layout

\begin_layout Plain Layout


\backslash
bitbox{2}{
\backslash
color{lightgray}
\backslash
rule{
\backslash
width}{
\backslash
height}} 
\end_layout

\begin_layout Plain Layout


\backslash
bitbox{2}{
\backslash
color{lightgray}
\backslash
rule{
\backslash
width}{
\backslash
height}} 
\end_layout

\begin_layout Plain Layout


\backslash
bitbox{2}{
\backslash
color{lightgray}
\backslash
rule{
\backslash
width}{
\backslash
height}} 
\end_layout

\begin_layout Plain Layout


\backslash
bitbox{2}{
\backslash
color{lightgray}
\backslash
rule{
\backslash
width}{
\backslash
height}} 
\end_layout

\begin_layout Plain Layout


\backslash
bitbox{2}{
\backslash
color{lightgray}
\backslash
rule{
\backslash
width}{
\backslash
height}} 
\end_layout

\begin_layout Plain Layout


\backslash
bitbox{2}{
\backslash
color{lightgray}
\backslash
rule{
\backslash
width}{
\backslash
height}} 
\end_layout

\begin_layout Plain Layout


\backslash
bitbox{2}{
\backslash
color{lightgray}
\backslash
rule{
\backslash
width}{
\backslash
height}} 
\end_layout

\begin_layout Plain Layout


\backslash
bitbox{2}{W}
\end_layout

\begin_layout Plain Layout


\backslash
bitbox{2}{E}
\end_layout

\begin_layout Plain Layout


\backslash
bitbox{2}{N}
\end_layout

\begin_layout Plain Layout


\backslash
bitbox{2}{E}
\end_layout

\begin_layout Plain Layout


\backslash
bitbox{2}{N}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
end{bytefield}
\end_layout

\begin_layout Plain Layout


\backslash
par
\backslash
end{centering}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:header_format"

\end_inset

Incoming header to switch
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\align center
\begin_inset Float figure
placement H
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{centering}
\end_layout

\begin_layout Plain Layout


\backslash
begin{bytefield}{34}
\end_layout

\begin_layout Plain Layout

   
\backslash
bitheader[b]{0-33} 
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

   
\backslash
bitbox{1}{1} 
\end_layout

\begin_layout Plain Layout

   
\backslash
bitbox{1}{0} 
\end_layout

\begin_layout Plain Layout


\backslash
bitbox{2}{
\backslash
color{lightgray}
\backslash
rule{
\backslash
width}{
\backslash
height}} 
\end_layout

\begin_layout Plain Layout


\backslash
bitbox{2}{
\backslash
color{lightgray}
\backslash
rule{
\backslash
width}{
\backslash
height}} 
\end_layout

\begin_layout Plain Layout


\backslash
bitbox{2}{
\backslash
color{lightgray}
\backslash
rule{
\backslash
width}{
\backslash
height}} 
\end_layout

\begin_layout Plain Layout


\backslash
bitbox{2}{
\backslash
color{lightgray}
\backslash
rule{
\backslash
width}{
\backslash
height}} 
\end_layout

\begin_layout Plain Layout


\backslash
bitbox{2}{
\backslash
color{lightgray}
\backslash
rule{
\backslash
width}{
\backslash
height}} 
\end_layout

\begin_layout Plain Layout


\backslash
bitbox{2}{
\backslash
color{lightgray}
\backslash
rule{
\backslash
width}{
\backslash
height}} 
\end_layout

\begin_layout Plain Layout


\backslash
bitbox{2}{
\backslash
color{lightgray}
\backslash
rule{
\backslash
width}{
\backslash
height}} 
\end_layout

\begin_layout Plain Layout


\backslash
bitbox{2}{
\backslash
color{lightgray}
\backslash
rule{
\backslash
width}{
\backslash
height}} 
\end_layout

\begin_layout Plain Layout


\backslash
bitbox{2}{
\backslash
color{lightgray}
\backslash
rule{
\backslash
width}{
\backslash
height}} 
\end_layout

\begin_layout Plain Layout


\backslash
bitbox{2}{
\backslash
color{lightgray}
\backslash
rule{
\backslash
width}{
\backslash
height}} 
\end_layout

\begin_layout Plain Layout


\backslash
bitbox{2}{
\backslash
color{lightgray}
\backslash
rule{
\backslash
width}{
\backslash
height}} 
\end_layout

\begin_layout Plain Layout


\backslash
bitbox{2}{
\backslash
color{lightgray}
\backslash
rule{
\backslash
width}{
\backslash
height}} 
\end_layout

\begin_layout Plain Layout


\backslash
bitbox{2}{W}
\end_layout

\begin_layout Plain Layout


\backslash
bitbox{2}{E}
\end_layout

\begin_layout Plain Layout


\backslash
bitbox{2}{N}
\end_layout

\begin_layout Plain Layout


\backslash
bitbox{2}{E}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
end{bytefield}
\end_layout

\begin_layout Plain Layout


\backslash
par
\backslash
end{centering}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:header_format-1"

\end_inset

Outgoing header from switch
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:header_proccessing"

\end_inset

Processing of header.
 This header specifies that the packet is to be routed towards the east
 output port of the switch.
 Header is then shifted.
 The final direction would route to the resource, not west.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Route towards resource if going backwards
\end_layout

\begin_layout Standard
An empty-space flit is a valid token that is processed by the HPU like any
 other flit, but ignored in the crossbar-stage.
 Likewise, empty-spaces are silently created at output of the crossbar-stage
 if nothing is routed towards an output port.
\end_layout

\begin_layout Standard
An empty-space has a binary representation of all-zero's.
 Hence empty-spaces can not interfere when entering the output-multiplexors/OR-g
ates of the crossbar.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename Figures/hpu_top.pdf
	width 12cm

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:HPU"

\end_inset

Simplified Header-parsing unit.
 Resetting by empty-spaces not shown.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
The HPU speculatively computes the one-hot decoded 
\begin_inset Formula $select$
\end_inset

 signal for use in the crossbar-stage.
 When it has been determined that the flit is a header, 
\begin_inset Formula $select$
\end_inset

 is latched forward to the crossbar-stage.
 
\end_layout

\begin_layout Standard
Since the select latch is a simple latch, not a token-latch, we should be
 careful to not accidentally opening it.
\end_layout

\begin_layout Standard
Assume early scheme 
\end_layout

\begin_layout Standard
sel should be set before the processed flit is latched into the token-latch.
\end_layout

\begin_layout Standard
As previously described, the bottom 32 bits of the header is shifted by
 2 bits, forming the new header that is parsed by the next switch.
 
\end_layout

\begin_layout Standard
What we shift in is don't care, since 
\end_layout

\begin_layout Standard
Currently 00 is shifted in 
\end_layout

\begin_layout Standard
The current implementation of the switch shifts the header by 2 bits, shifting
 in 00.
 Since the last hop will route to the resource, these 2 bits are don't care
\end_layout

\begin_layout Standard
currently shifts 00 into the route of headers.
 
\end_layout

\begin_layout Subsubsection
Crossbar
\begin_inset Marginal
status open

\begin_layout Plain Layout
Rasmus
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The crossbar we have implemented is fully generic, and can be instantiated
 with a given number of channels (A channels is one input port and one output
 port), it should be noted that the crossbar is a fully connected network,
 thus it does not scale linearly.
 To simplify the logic, the select signal to the de-multiplexers is one-hot
 encoded.
 This results in a de-multiplexer that can be made from a number of parallel
 
\noun on
and
\noun default
 gates, the logic depth is only one 
\noun on
and
\noun default
 gate, making the de-multiplexer very fast.
\end_layout

\begin_layout Standard
Because of the property of the static routing protocol, only one phit is
 routed to one output port of a switch in each time slot.
 The multiplexer can simply be implemented as a number of parallel 
\noun on
or
\noun default
 gates, also a logic depth of one 
\noun on
or
\noun default
 gate.
\end_layout

\begin_layout Paragraph
Synchronization of time slots
\end_layout

\begin_layout Standard
Synchronization of the time slots are done by waiting for packets on all
 the input channels, when all input packets are ready they are transferred
 to the output latches of the crossbar stage of the switch, C-elements are
 used to synchronize the request and acknowledge signals.
\end_layout

\begin_layout Subsubsection
Latches
\begin_inset Marginal
status open

\begin_layout Plain Layout
Mark
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Testbench
\begin_inset Marginal
status open

\begin_layout Plain Layout
Madava
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Contains assertions, like unit test
\end_layout

\begin_layout Standard
picture of route in mesh
\end_layout

\begin_layout Standard
Show figure of testbench
\end_layout

\begin_layout Standard
Explain heatmaps.
 They help in visualize dynamic behavior of the mesh network.
 
\end_layout

\begin_layout Standard
relative changes
\end_layout

\begin_layout Standard
cycle time and phase
\end_layout

\begin_layout Standard
Figures are discussed under the Performance characteristics section.
\end_layout

\begin_layout Section
Performance characteristics
\begin_inset Marginal
status open

\begin_layout Plain Layout
Rasmus
\end_layout

\end_inset


\end_layout

\begin_layout Standard
In this project we will concentrate on simulation, even though we have implement
ed the switch in synthesizable VHDL.
 The performance characteristics of our switch nodes will only be investigated
 through behavioral simulations, with the propagation delays we have specified.
 Therefore we can not give any real values for the characteristics.
\end_layout

\begin_layout Standard
What we can investigate is how the network is able to cope with fluctuating
 propagation delays on links and how it handles phase changes between nodes
 in the network.
\end_layout

\begin_layout Standard
The network will of course in steady state only be as fast as the slowest
 node in the network, because of the synchronization.
 When we introduce an increase in propagation delay on a wire, we can visualize
 the change in bandwidth of the network, by plotting the cycle time for
 the synchronized request signal for each switch node in the network.
 The plotted cycle time of the synchronized request signal can be seen in
 figure
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Cycle-times"

\end_inset

, where blue is the lowest and initial cycle time and red is the highest
 cycle time.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename 9x9/tcycle0015.png
	scale 50

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:Cycle-time-a"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset

 
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename 9x9/tcycle0018.png
	scale 50

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:Cycle-time-b"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset

 
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename 9x9/tcycle0019.png
	scale 50

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:Cycle-time-c"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset

 
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename 9x9/tcycle0021.png
	scale 50

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:Cycle-time-d"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset

 
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename 9x9/tcycle0024.png
	scale 50

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:Cycle-time-e"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:Cycle-times"

\end_inset

Cycle times for synchronized request signals 
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
In figure
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Cycle-time-a"

\end_inset

 the wave of larger cycle times has started to propagate into the network
 from the point where the extra wire delay was introduced.
 Note that in figure
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Cycle-time-c"

\end_inset

 back of the wave appear.
 In figure
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Cycle-time-e"

\end_inset

 the wave has almost propagated out of the network.
\end_layout

\begin_layout Standard
At the end of the simulation, the cycle time is the same as the initial
 cycle time, but the state of the network is not the same as the initial
 state.
 The phase of the handshake cycle at the beginning and the end of the simulation
 can be seen in figure
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Handshake-phase"

\end_inset

.
 Figure
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Phase-beginning"

\end_inset

 is the phase of the handshake cycle at the beginning of the simulation
 and figure
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Phase-end"

\end_inset

 is the phase of the handshake cycle at the end of the simulation.
 The color of the phase is not important, but the color difference is.
 It is seen that the phase of the handshake cycle is uniform at the beginning
 of the simulation.
 At the end of the simulation, after the cycle time has recovered, the phase
 is no longer uniform.
 We have calculated the phase difference between the blue area and the read
 area to be approximately 
\begin_inset ERT
status open

\begin_layout Plain Layout

$820^
\backslash
circ$
\end_layout

\end_inset

.
 Meaning that the read area is more than two time slots behind the blue
 area.
 Showing the true elasticity of the asynchronous NoC, comparing these results
 to the synchronous case, the synchronous case would have to be able to
 tolerate a skew of more than twice the clock period.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename 9x9/phase0000.png
	scale 50

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:Phase-beginning"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset

 
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename 9x9/phase0048.png
	scale 50

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:Phase-end"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:Handshake-phase"

\end_inset

The phase of the handshake cycle at (a)the beginning of the simulation and
 at (b)the end of the simulation.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
The reason why the network can tolerate such a large phase difference is
 because of bufferspace in the link and HPU between two neighboring switch
 crossbars.
 This phase difference in the network will result in changing latencies
 in the network, depending on the taken route.
 The phase difference will never be larger than the tolerable phase difference
 in the network, because it normalizes itself by momentarily lowering the
 bandwidth in parts of the network.
\end_layout

\begin_layout Section
Discussion
\begin_inset Marginal
status open

\begin_layout Plain Layout
Rasmus
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The asynchronous Fibonacci circuit can run in an FPGA, this shows the basic
 primitives, we have implemented, work (Latches, C-elements, ...).
 One thing missing for the NoC to run in an FPGA is the matched delays on
 the request signals.
 Matched delays could be avoided by using dual-rail instead of bundled data.
 
\end_layout

\begin_layout Standard
While we have focused purely on the interconnect, for a full NoC implementation
 it is also required that each resource has its own Network Interface (NI).
 The NI should contain Routing tables and time slot information, and do
 the translation of an address of a resource to a time slot and a route.
 The information on which time slot should be sent now, from the NI, is
 taken care of by a counter that increments its value after each handshake.
 The counters of all the NIs can be reset, by a global reset signal.
\end_layout

\begin_layout Standard
In our simulation we do not take the possibility of token Clumping into
 account.
 Clumping of tokens in self-timed rings is a phenomenon that will not show
 up in a simulation with our simple model of the C-gates.
 In [Reference Grenoble self-time ring oscillators...] we see that for tokens
 to clump together the C-gate model should change faster if it has been
 changes recently, the propagation delay is smaller right after the C-element
 just changed.
\end_layout

\begin_layout Standard
We recommend that the phenomenon of token clumping should be investigated
 further, possibly in simulation by making a more precise model of the C-element
s.
\end_layout

\begin_layout Standard
Further investigate how phase changes permanent.
\end_layout

\begin_layout Section
Conclusion
\begin_inset Marginal
status open

\begin_layout Plain Layout
Rasmus
\end_layout

\end_inset


\end_layout

\begin_layout Standard
We have designed and implemented an interconnect, which does not use a global
 clock and scales well with many resources.
 The interconnect is based on the asynchronous Æthereal TDMA Network-on-Chip
 designed by Philips.
 Our implementation works as expected in simulation.
 The Performance of the network should be investigated further to determine
 the more precise characteristics.
\end_layout

\begin_layout Standard
Cycle times are as expected
\end_layout

\begin_layout Standard
Interesting observation that requires further investigation.
\end_layout

\begin_layout Standard
Phase is not as expected, but has no performance impact.
\end_layout

\begin_layout Standard
Stochastic delays.
\end_layout

\end_body
\end_document
