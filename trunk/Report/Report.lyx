#LyX 2.0 created this file. For more info see http://www.lyx.org/
\lyxformat 413
\begin_document
\begin_header
\textclass article
\begin_preamble
\usepackage{bytefield}

\usepackage{tikz-timing}


\usepackage{tikz}
\usetikzlibrary{shapes,snakes,calendar,matrix,backgrounds,folding}
\end_preamble
\use_default_options true
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding auto
\fontencoding global
\font_roman lmodern
\font_sans lmss
\font_typewriter default
\font_default_family sfdefault
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100

\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing single
\use_hyperref false
\papersize a4paper
\use_geometry true
\use_amsmath 1
\use_esint 1
\use_mhchem 1
\use_mathdots 1
\cite_engine natbib_authoryear
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\use_refstyle 1
\index Index
\shortcut idx
\color #008000
\end_index
\leftmargin 3.25cm
\rightmargin 3.25cm
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Title
Design and Implementation of an Asynchronous TDMA Network-on-Chip
\end_layout

\begin_layout Author
Rasmus Bo Sørensen 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
and
\end_layout

\end_inset

 Mark Ruvald Pedersen 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
and
\end_layout

\end_inset

 Madava Dilshan Vithanage
\end_layout

\begin_layout Abstract
We have designed and implemented an asynchronous TDMA Network-on-Chip on
 the basis of the Æthereal Network-on-Chip initialy designed by Philips.
 We have analysed the basic elasticity characteristics of our implementation
 and seen that the speed of the network recovers after an increased delay
 on a link, and that the network is elastic in the sens that it can absorb
 phase differences in the network, with out lowering the speed of the network.
\end_layout

\begin_layout Section
Introduction
\begin_inset Marginal
status open

\begin_layout Plain Layout
Rasmus
\end_layout

\end_inset


\end_layout

\begin_layout Standard
When facing hundreds of cores on a single chip in the near future, the interconn
ection network becomes an even more important part of any design.
 The cost of such a network should be low in comparison to the cores, scale
 linearly with number of cores, and allow as much concurrent (contention-free)
 communcation as possible.
 Making the traffic in the interconnect packet-based enables many packets
 to be routed in the interconnect simultaniously.
 A Network-on-Chip (NoC) is a packet-based interconnect that scales very
 well with the number of resources in the system.
\end_layout

\begin_layout Standard
As chips become larger the difficulties of routing one global clock to the
 whole chip (with an acceptable skew) makes it infeasible to have a global
 clock.
 Avoiding the global clock is a tremendous advantage, especialy compare
 to power usage.
 Designing an Asynchronous NoC would solve the problem of bandwidth and
 the problem of routing one global clock.
\end_layout

\begin_layout Section
Design and Implementation
\end_layout

\begin_layout Subsection
Asynchronous TDMA Network-on-Chip
\begin_inset Marginal
status open

\begin_layout Plain Layout
Rasmus
\end_layout

\end_inset


\end_layout

\begin_layout Standard
We will design and implement an asyncronous TDMA Network-on-Chip, on the
 basis of the Æthereal NoC, designed by Philips.
 TDMA stands for Time Division Multiple Access, which means the communication
 resources are divided in time and split into sections allowing multiple
 data units to be routed simultainiously.
\end_layout

\begin_layout Standard
The Æthereal NoC is a statically scheduled NoC, where a compile-time schedule
 has been made that ensures no two data units are routed on the same link
 at once.
\end_layout

\begin_layout Standard
Dividing communication resources into timeslots, require synchronization
 of these resources, to make sure that no timeslots are dropped.
 In a synchronous NoC this synchronization is easily derived from the global
 clock.
 In our asynchronous implementation the synchronization is done by waiting
 for data units on all inputs of a node to be present, before routing them
 through the switch.
 Ensures that no data units are dropped and that the timeslots are transmitted
 in order.
 This synchronization does not mean that all links at all time will be transmitt
ing the same timeslot, but it means that each switch transmittes the same
 timeslots at once.
 Asynchronous circuits are elastic with respect to timing.
 In our NoC the elasticity means that constant phase differences between
 the transmission of flits in two neighboring switches as well as minor
 fluctuation in the propergation delays of links, can be absorbed by the
 network.
\end_layout

\begin_layout Subsection
\begin_inset CommandInset label
LatexCommand label
name "sub:Protocol"

\end_inset

Protocol
\begin_inset Marginal
status open

\begin_layout Plain Layout
Mark
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Our protocol is simplistic: Packets are statically source-routed using cut-throu
gh routing, with 1
\begin_inset space ~
\end_inset

flit being equal to 1
\begin_inset space ~
\end_inset

phit.
 Packets can however consist of an arbitrary number of flits.
 Delimitation of packets is indicated by the 
\emph on
Start-Of-Packet
\emph default
 (SOP) and 
\emph on
End-Of-Packet
\emph default
 (EOP) bit fields, as shown in figure
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "fig:flit_format"

\end_inset

.
 
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{centering}
\end_layout

\begin_layout Plain Layout


\backslash
begin{bytefield}{34}
\end_layout

\begin_layout Plain Layout

   
\backslash
bitheader[b]{0-33} 
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

   
\backslash
bitbox{1}{
\backslash
rotatebox{90}{
\backslash
tiny SOP}} &
\end_layout

\begin_layout Plain Layout

   
\backslash
bitbox{1}{
\backslash
rotatebox{90}{
\backslash
tiny EOP}} &
\end_layout

\begin_layout Plain Layout

   
\backslash
bitbox{32}{Payload/route}
\end_layout

\begin_layout Plain Layout

 
\backslash
end{bytefield}
\end_layout

\begin_layout Plain Layout


\backslash
par
\backslash
end{centering}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:flit_format"

\end_inset

General format of all flits.
\end_layout

\end_inset


\end_layout

\end_inset

SOP and EOP are used to encode four types of flits (SOP,EOP):
\end_layout

\begin_layout Description
(0,0)
\begin_inset space ~
\end_inset

Empty
\begin_inset space ~
\end_inset

space: A dummy flit that is sent when no real data is to be transmitted.
 The existence of empty-spaces is required since all input ports of the
 switch must provide tokens before any tokens are sent by the switch.
 
\end_layout

\begin_layout Description
(1,0)
\begin_inset space ~
\end_inset

Header: Holds the route.
 The route is a sequence of directions that the entire packet should follow.
\end_layout

\begin_layout Description
(1,1)
\begin_inset space ~
\end_inset

Body: Holds the actual payload data that is to be delivered to destination
 resource.
\end_layout

\begin_layout Description
(0,1)
\begin_inset space ~
\end_inset

End
\begin_inset space ~
\end_inset

body: Holds payload data - like a body-flit - but also signifies the last
 flit of packet.
 
\end_layout

\begin_layout Standard
Figure
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "fig:packet_timing"

\end_inset

 shows how SOP and EOP are grey-encoded as a function of flit-type.
 Hence packets always begin with a header, followed by zero or more bodies
 and end with a end-body.
 There may be zero or more empty-spaces between packets.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement h
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
begin{centering}
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

 
\backslash
begin{tikztimingtable}[xscale=1, yscale=1, semithick] 
\end_layout

\begin_layout Plain Layout

     
\backslash
normalsize{SOP}      & L HHH HHH HHH LLL LLL  
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

     
\backslash
normalsize{EOP}      & L LLL HHH HHH HHH LLL 
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

     
\backslash
phantom{
\backslash
normalsize{Data}}      &   
\backslash

\backslash

\end_layout

\begin_layout Plain Layout


\backslash
end{tikztimingtable}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

 
\backslash
begin{tikztimingtable}[xscale=1, yscale=2, semithick] 
\end_layout

\begin_layout Plain Layout

   
\backslash
normalsize{Data} & T 
\end_layout

\begin_layout Plain Layout

3D{$
\backslash
begin{array}{c} 
\backslash
mbox{
\backslash
fontsize{10}{2}
\backslash
selectfont 
\backslash
raisebox{-0.7ex}{Start}} 
\backslash

\backslash
 
\backslash
mbox{
\backslash
fontsize{10}{2}
\backslash
selectfont header} 
\backslash
end{array}$} 
\end_layout

\begin_layout Plain Layout

3D{Body} 
\end_layout

\begin_layout Plain Layout

3D{Body} 
\end_layout

\begin_layout Plain Layout

3D{$
\backslash
begin{array}{c} 
\backslash
mbox{
\backslash
fontsize{10}{2}
\backslash
selectfont 
\backslash
raisebox{-0.7ex}{End}} 
\backslash

\backslash
 
\backslash
mbox{
\backslash
fontsize{10}{2}
\backslash
selectfont body} 
\backslash
end{array}$}  
\end_layout

\begin_layout Plain Layout

3L{$
\backslash
begin{array}{c} 
\backslash
mbox{
\backslash
fontsize{10}{2}
\backslash
selectfont 
\backslash
raisebox{-0.7ex}{Empty}} 
\backslash

\backslash
 
\backslash
mbox{
\backslash
fontsize{10}{2}
\backslash
selectfont space} 
\backslash
end{array}$} 
\backslash

\backslash

\end_layout

\begin_layout Plain Layout


\backslash
extracode
\end_layout

\begin_layout Plain Layout

 
\backslash
begin{pgfonlayer}{background}
\end_layout

\begin_layout Plain Layout

 
\backslash
node [anchor=south east] at (16.3, 0.2) {
\backslash
fontsize{6}{2}
\backslash
selectfont Empty};
\end_layout

\begin_layout Plain Layout

 
\backslash
node [anchor=south east] at (16.2, -0.2) {
\backslash
fontsize{6}{2}
\backslash
selectfont space};
\end_layout

\begin_layout Plain Layout


\backslash
end{pgfonlayer}
\end_layout

\begin_layout Plain Layout

 
\backslash
end{tikztimingtable}
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout


\backslash
par
\backslash
end{centering}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:packet_timing"

\end_inset

Example of timing diagram of a packet with 4 flits, 3 of which carry payload.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Since we are using cut-through source-routing, it is only possible to store
 the route in the first few flits of a packet -- the header.
 In our case the header is only 1
\begin_inset space ~
\end_inset

flit long, and contains the full remaining route: It contains only what
 
\emph on
remains
\emph default
 of the route, since previous routing-directions are shifted out for each
 hop made.
 As we will see later, this allows for simple routing-decision logic since
 the destination-port is always specified by the two least significant bits;
 cf.
 figure
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "fig:header_proccessing"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement h
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Float figure
placement H
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
begin{centering}
\end_layout

\begin_layout Plain Layout


\backslash
begin{bytefield}{34}
\end_layout

\begin_layout Plain Layout

   
\backslash
bitheader[b]{0-33} 
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

   
\backslash
bitbox{1}{1} 
\end_layout

\begin_layout Plain Layout

   
\backslash
bitbox{1}{0} 
\end_layout

\begin_layout Plain Layout


\backslash
bitbox{2}{
\backslash
color{lightgray}
\backslash
rule{
\backslash
width}{
\backslash
height}} 
\end_layout

\begin_layout Plain Layout


\backslash
bitbox{2}{
\backslash
color{lightgray}
\backslash
rule{
\backslash
width}{
\backslash
height}} 
\end_layout

\begin_layout Plain Layout


\backslash
bitbox{2}{
\backslash
color{lightgray}
\backslash
rule{
\backslash
width}{
\backslash
height}} 
\end_layout

\begin_layout Plain Layout


\backslash
bitbox{2}{
\backslash
color{lightgray}
\backslash
rule{
\backslash
width}{
\backslash
height}} 
\end_layout

\begin_layout Plain Layout


\backslash
bitbox{2}{
\backslash
color{lightgray}
\backslash
rule{
\backslash
width}{
\backslash
height}} 
\end_layout

\begin_layout Plain Layout


\backslash
bitbox{2}{
\backslash
color{lightgray}
\backslash
rule{
\backslash
width}{
\backslash
height}} 
\end_layout

\begin_layout Plain Layout


\backslash
bitbox{2}{
\backslash
color{lightgray}
\backslash
rule{
\backslash
width}{
\backslash
height}} 
\end_layout

\begin_layout Plain Layout


\backslash
bitbox{2}{
\backslash
color{lightgray}
\backslash
rule{
\backslash
width}{
\backslash
height}} 
\end_layout

\begin_layout Plain Layout


\backslash
bitbox{2}{
\backslash
color{lightgray}
\backslash
rule{
\backslash
width}{
\backslash
height}} 
\end_layout

\begin_layout Plain Layout


\backslash
bitbox{2}{
\backslash
color{lightgray}
\backslash
rule{
\backslash
width}{
\backslash
height}} 
\end_layout

\begin_layout Plain Layout


\backslash
bitbox{2}{
\backslash
color{lightgray}
\backslash
rule{
\backslash
width}{
\backslash
height}} 
\end_layout

\begin_layout Plain Layout


\backslash
bitbox{2}{
\backslash
color{lightgray}
\backslash
rule{
\backslash
width}{
\backslash
height}} 
\end_layout

\begin_layout Plain Layout


\backslash
bitbox{2}{N}
\end_layout

\begin_layout Plain Layout


\backslash
bitbox{2}{S}
\end_layout

\begin_layout Plain Layout


\backslash
bitbox{2}{N}
\end_layout

\begin_layout Plain Layout


\backslash
bitbox{2}{E}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
end{bytefield}
\end_layout

\begin_layout Plain Layout


\backslash
par
\backslash
end{centering}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:header_format"

\end_inset

Incoming header to switch
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\align center
\begin_inset Float figure
placement H
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{centering}
\end_layout

\begin_layout Plain Layout


\backslash
begin{bytefield}{34}
\end_layout

\begin_layout Plain Layout

   
\backslash
bitheader[b]{0-33} 
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

   
\backslash
bitbox{1}{1} 
\end_layout

\begin_layout Plain Layout

   
\backslash
bitbox{1}{0} 
\end_layout

\begin_layout Plain Layout


\backslash
bitbox{2}{
\backslash
color{lightgray}
\backslash
rule{
\backslash
width}{
\backslash
height}} 
\end_layout

\begin_layout Plain Layout


\backslash
bitbox{2}{
\backslash
color{lightgray}
\backslash
rule{
\backslash
width}{
\backslash
height}} 
\end_layout

\begin_layout Plain Layout


\backslash
bitbox{2}{
\backslash
color{lightgray}
\backslash
rule{
\backslash
width}{
\backslash
height}} 
\end_layout

\begin_layout Plain Layout


\backslash
bitbox{2}{
\backslash
color{lightgray}
\backslash
rule{
\backslash
width}{
\backslash
height}} 
\end_layout

\begin_layout Plain Layout


\backslash
bitbox{2}{
\backslash
color{lightgray}
\backslash
rule{
\backslash
width}{
\backslash
height}} 
\end_layout

\begin_layout Plain Layout


\backslash
bitbox{2}{
\backslash
color{lightgray}
\backslash
rule{
\backslash
width}{
\backslash
height}} 
\end_layout

\begin_layout Plain Layout


\backslash
bitbox{2}{
\backslash
color{lightgray}
\backslash
rule{
\backslash
width}{
\backslash
height}} 
\end_layout

\begin_layout Plain Layout


\backslash
bitbox{2}{
\backslash
color{lightgray}
\backslash
rule{
\backslash
width}{
\backslash
height}} 
\end_layout

\begin_layout Plain Layout


\backslash
bitbox{2}{
\backslash
color{lightgray}
\backslash
rule{
\backslash
width}{
\backslash
height}} 
\end_layout

\begin_layout Plain Layout


\backslash
bitbox{2}{
\backslash
color{lightgray}
\backslash
rule{
\backslash
width}{
\backslash
height}} 
\end_layout

\begin_layout Plain Layout


\backslash
bitbox{2}{
\backslash
color{lightgray}
\backslash
rule{
\backslash
width}{
\backslash
height}} 
\end_layout

\begin_layout Plain Layout


\backslash
bitbox{2}{
\backslash
color{lightgray}
\backslash
rule{
\backslash
width}{
\backslash
height}} 
\end_layout

\begin_layout Plain Layout


\backslash
bitbox{2}{
\backslash
color{lightgray}
\backslash
rule{
\backslash
width}{
\backslash
height}} 
\end_layout

\begin_layout Plain Layout


\backslash
bitbox{2}{N}
\end_layout

\begin_layout Plain Layout


\backslash
bitbox{2}{S}
\end_layout

\begin_layout Plain Layout


\backslash
bitbox{2}{N}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
end{bytefield}
\end_layout

\begin_layout Plain Layout


\backslash
par
\backslash
end{centering}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:header_format-1"

\end_inset

Outgoing header from switch
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:header_proccessing"

\end_inset

Processing of header.
 This header specifies that the packet is to be routed towards the east
 output port of the switch.
 Header is then shifted.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Route towards resource if going backwards
\end_layout

\begin_layout Standard
An empty-space flit is a valid token that is processed by the HPU like any
 other flit, but ignored in the crossbar-stage.
 Likewise, empty-spaces are silently created at output of the crossbar-stage
 if nothing is routed towards an output port.
\end_layout

\begin_layout Standard
An empty-space has a binary representation of all-zero's.
 Hence empty-spaces can not interfere when entering the output-multiplexors/OR-g
ates of the crossbar.
\end_layout

\begin_layout Standard
Maximum of (34-2)/2=16 hops can be encoded in the header.
 If the mesh is to be square and any resource should be able to communicte
 any other resource, this 16 hop limit, restricts us to 
\begin_inset Formula $9\times9$
\end_inset

 meshes
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
\begin_inset Formula $2(n-1)=16\iff n=9$
\end_inset

.
\end_layout

\end_inset

.
\end_layout

\begin_layout Subsection
Switch
\begin_inset Marginal
status open

\begin_layout Plain Layout
Madava
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Internal structure: Our switch consists of an routing unit (HPU) followed
 by a crossbar.
\end_layout

\begin_layout Standard
Idealized symbol of switch.
 
\end_layout

\begin_layout Standard
Port indices for N,S,E,W,R
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
Insert overall block diagram of switch - similar to the phillips paper
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
HPU
\begin_inset Marginal
status open

\begin_layout Plain Layout
Mark
\end_layout

\end_inset


\end_layout

\begin_layout Standard
As mentioned in the protocol description, the entire route is contained
 in the header.
 All flits of the packet should be routed as specified by the next-hop field
 in the header.
 Hence the routing-logic has to:
\end_layout

\begin_layout Enumerate
Identify the header.
\end_layout

\begin_layout Enumerate
If a header is found:
\end_layout

\begin_deeper
\begin_layout Enumerate
Parse the header -- setting the crossbar according to next-hop field,
\end_layout

\begin_layout Enumerate
Update the route such that the next-next-hop will become the next-hop at
 the next switch.
\end_layout

\end_deeper
\begin_layout Enumerate
Keep crossbar-settings for all flits of the packet.
\end_layout

\begin_deeper
\begin_layout Enumerate
Reset settings upon receiving an empty-space.
\end_layout

\end_deeper
\begin_layout Enumerate
Leave non-header flits unaltered.
\end_layout

\begin_layout Standard
Since we assign special meaning to the header of each packet, our protocol
 is stateful.
 This makes the 
\emph on
header-parsing unit
\emph default
 the most complex part of our switch.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename Figures/hpu_top.pdf
	width 10cm

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:HPU"

\end_inset

Simplified Header-parsing unit.
 Resetting by empty-spaces not shown.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
The HPU speculatively computes the one-hot decoded 
\begin_inset Formula $select$
\end_inset

 signal for use in the crossbar-stage.
 When it has been determined that the flit is a header, 
\begin_inset Formula $select$
\end_inset

 is latched forward to the crossbar-stage.
 
\end_layout

\begin_layout Standard
Since the select latch is a simple latch, not a token-latch, we should be
 careful to not accidentally opening it.
\end_layout

\begin_layout Standard
Assume early scheme 
\end_layout

\begin_layout Standard
sel should be set before the processed flit is latched into the token-latch.
\end_layout

\begin_layout Standard
As previously described, the bottom 32 bits of the header is shifted by
 2 bits, forming the new header that is parsed by the next switch.
 
\end_layout

\begin_layout Standard
What we shift in is don't care, since 
\end_layout

\begin_layout Standard
Currently 00 is shifted in 
\end_layout

\begin_layout Standard
The current implementation of the switch shifts the header by 2 bits, shifting
 in 00.
 Since the last hop will route to the resource, these 2 bits are don't care
\end_layout

\begin_layout Standard
currently shifts 00 into the route of headers.
 
\end_layout

\begin_layout Subsubsection
Crossbar
\begin_inset Marginal
status open

\begin_layout Plain Layout
Rasmus
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The crossbar we have implemented is fully generic, and can be instantiated
 with a given number of channels (A channels is one input port and one output
 port), it should be noted that the crossbar is a fully connected network,
 thus it does not scale linearly.
 To simplify the logic, the select signal to the de-multiplexers is one-hot
 encoded.
 This results in a de-multiplexer that can be made from a number of parallel
 
\noun on
and
\noun default
 gates, the logic depth is only one 
\noun on
and
\noun default
 gate, making the de-multiplexer very fast.
\end_layout

\begin_layout Standard
Because of the property of the static routing protocol, only one phit is
 routed to one output port of a switch in each timeslot.
 The multiplexer can simply be implemented as a number of parallel 
\noun on
or
\noun default
 gates, also a logic depth of one 
\noun on
or
\noun default
 gate.
\end_layout

\begin_layout Paragraph
Synchronization of timeslots
\end_layout

\begin_layout Standard
Synchronization of the timeslots are done, by waiting for packets on all
 the input channels, when all input packets are ready they are transmitted
 to the output latches of the switch, C-elements are used to synchronize
 the request signals.
\end_layout

\begin_layout Subsubsection
Latches
\begin_inset Marginal
status open

\begin_layout Plain Layout
Mark
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Testbench
\begin_inset Marginal
status open

\begin_layout Plain Layout
Madava
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Contains assertions, like unit test
\end_layout

\begin_layout Standard
picture of route in mesh
\end_layout

\begin_layout Standard
Show figure of testbench
\end_layout

\begin_layout Standard
Explain heatmaps.
 They help in visualise dynamic behavior of the mesh network.
 
\end_layout

\begin_layout Standard
relative changes
\end_layout

\begin_layout Standard
cycle time and phase
\end_layout

\begin_layout Standard
Figures are disussed under the Performance characteristics section.
\end_layout

\begin_layout Section
Performance characteristics
\begin_inset Marginal
status open

\begin_layout Plain Layout
Rasmus
\end_layout

\end_inset


\end_layout

\begin_layout Standard
In this project we will concentrate on simulation, even though we have implement
ed the switch in synthesisable VHDL.
 The performance characteristics of our switch nodes will only be investigated
 through behavioral simulations, with the propergation delays we have specified.
 Therefore we can not give any real values for the characteristics.
\end_layout

\begin_layout Standard
What we can investigate is how the elasticity is able to cope with fluctuating
 propergation delays on links and how the network handles phase changes
 between nodes in the network.
\end_layout

\begin_layout Standard
The network will of course in steady state only be as fast as the slowest
 part of the network, this is a requirement to keep the synchronization.
 When we introduce an increase in propergation delay on a wire, we can visualize
 the speed of the network, by plotting the cycle time for the synchronized
 request signal for each switch node in the network.
 This visualization can be seen in figure
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Cycle-times"

\end_inset

, where blue is the lowest and initial cycle time and red is the highes
 cycle time.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename 9x9/tcycle0015.png
	scale 50

\end_inset

 
\begin_inset Graphics
	filename 9x9/tcycle0018.png
	scale 50

\end_inset

 
\begin_inset Graphics
	filename 9x9/tcycle0019.png
	scale 50

\end_inset

 
\begin_inset Graphics
	filename 9x9/tcycle0021.png
	scale 50

\end_inset

 
\begin_inset Graphics
	filename 9x9/tcycle0024.png
	scale 50

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:Cycle-times"

\end_inset

Cycle times for synchronized request signals 
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard

\end_layout

\begin_layout Standard
In the heat map it is seen that....
\end_layout

\begin_layout Standard
At the end of the simulation, the cycle time is the same as the initial
 cycle time, but the state of the network is not the same as the initial
 state.
 The phase of the handshake cycle at the beginning and the end of the simulation
 can be seen in figure
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Handshake-phase"

\end_inset

.
 The picture to the left is the phase of the handshake cycle at the beginning
 of the simulation and the picture on the right is the phase of the handshake
 cycle at the end of the simulation.
 The color of the fase is not important, but the color difference is.
 It is seen that the phase of the handshake cycle is uniform at the beginning
 of the simulation.
 At the end of the simulation, after the cycle time has recovered, the phase
 is no longer uniform.
 We have calculated the phase difference between the blue area and the read
 area to be approximately 
\begin_inset ERT
status open

\begin_layout Plain Layout

$820^
\backslash
circ$
\end_layout

\end_inset

.
 Meaning that the read area is more than two timeslots behind the blue area.
 Showing the true elasticity of the asynchronous NoC, comparing these results
 to the synchronous case, the synchronous case would have to be able to
 tolerate a skew of more than twice the clock period.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename 9x9/phase0000.png
	scale 50

\end_inset

 
\begin_inset Graphics
	filename 9x9/phase0048.png
	scale 50

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:Handshake-phase"

\end_inset

The phase of the handshake cycle at the beginning and at the end of the
 simulation.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
The reason why the network can tolerate such a large phase difference is
 because there are some bufferspace in the link and HPU between two neighboring
 switch crossbars.
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
Explaining the permanent phase change in the steadystate - even after delay
 has gone.
 Mesosynchronous.
 Buffer space in latches.
 
\end_layout

\end_inset


\end_layout

\begin_layout Section
Discussion
\begin_inset Marginal
status open

\begin_layout Plain Layout
Rasmus
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The asynchronous fibonaci circuit can run in an FPGA, this shows the basic
 primetives work (Latches, C-elements, ...) The only thing preventing our NoC
 from runing an an FPGA is the matched delays.
 Everything is synthesizable.
 Matched delays could be avoided by using dual-rail instead of bundled data.
 
\end_layout

\begin_layout Standard
While we have focused purely on the interconnect, for a full NoC implementation
 we would also require Network Interfaces at every resource.
 Routing tables and timeslot information.
\end_layout

\begin_layout Standard
Timeslotting is higher level protocol.
\end_layout

\begin_layout Standard
To determine in which timeslot the NI is in, a simple counter is used to
 count handshakes.
\end_layout

\begin_layout Standard
Definition of a flit is up to the NI.
 Our switch works a phit-level, and the NI could decide that 1 flit is 2
 phits.
\end_layout

\begin_layout Standard
resetting
\end_layout

\begin_layout Standard
our switch implementation supports arbitrary length of flits in a packet.
\end_layout

\begin_layout Standard
the larger the packet, the less overhead.
\end_layout

\begin_layout Standard
Our main design decision has been to minimize swtich complexity, at a cost
 of NI complexity.
 In fact the swtich can't be any simpler.
\end_layout

\begin_layout Standard
Clumping of tokens in self-timed rings is a phenomenon that vil not show
 up in a simulation with our simple model of the C-gates.
 In [Reference Grenoble self-time ring oscilators...] we see that for tokens
 to clump thogether the C-gate model should change faster if it has been
 changes reasonally, the propergation delay is smaller right after the C-element
 just changed.
 
\end_layout

\begin_layout Section
Conclusion
\begin_inset Marginal
status open

\begin_layout Plain Layout
Rasmus
\end_layout

\end_inset


\end_layout

\begin_layout Standard
We have implemented a working asynchrounous TDMA network-on-chip.
 It works.
 
\end_layout

\begin_layout Standard
We simulated
\end_layout

\begin_layout Standard
Further investigate how phase changes perma.
\end_layout

\begin_layout Standard
Injecting delays, had an expected 
\end_layout

\begin_layout Standard
Cycle times are as expected
\end_layout

\begin_layout Standard
Interesting observation that requires further investigation.
\end_layout

\begin_layout Standard
Phase is not as expected, but has no performance impact.
\end_layout

\begin_layout Standard
Stochastic delays.
\end_layout

\begin_layout Standard
We have designed and implemented an interconnect, which does not use a global
 clock and scales well with many resources.
 The interconnect we have desingned
\end_layout

\end_body
\end_document
