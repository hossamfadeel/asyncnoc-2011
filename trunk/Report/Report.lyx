#LyX 2.0 created this file. For more info see http://www.lyx.org/
\lyxformat 413
\begin_document
\begin_header
\textclass article
\begin_preamble
\usepackage{bytefield}
\end_preamble
\use_default_options true
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding auto
\fontencoding global
\font_roman lmodern
\font_sans lmss
\font_typewriter default
\font_default_family sfdefault
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100

\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing single
\use_hyperref false
\papersize a4paper
\use_geometry true
\use_amsmath 1
\use_esint 1
\use_mhchem 1
\use_mathdots 1
\cite_engine natbib_authoryear
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\use_refstyle 1
\index Index
\shortcut idx
\color #008000
\end_index
\leftmargin 3.25cm
\rightmargin 3.25cm
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Title
Design and Implementation of an Asynchronous TDMA Network-on-Chip
\end_layout

\begin_layout Author
Rasmus Bo Sørensen 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
and
\end_layout

\end_inset

 Mark Ruvald Pedersen 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
and
\end_layout

\end_inset

 Madava Dilshan Vithanage
\end_layout

\begin_layout Section
Introduction
\begin_inset Marginal
status open

\begin_layout Plain Layout
Rasmus
\end_layout

\end_inset


\end_layout

\begin_layout Standard
When facing hundreds of cores on a single chip in the near future, the interconn
ection network becomes an even more important part of any design.
 The cost of such a network should be low in comparison to the cores, scale
 linearly with number of cores, and allow as much concurrent (contention-free)
 communcation as possible.
 Making the traffic in the interconnect packet-based enables many packets
 to be routed in the interconnect simultaniously.
 A Network-on-Chip (NoC) is a packet-based interconnect that scales very
 well with the number of resources in the system.
\end_layout

\begin_layout Standard
As chips become larger the difficulties of routing one global clock to the
 whole chip (with an acceptable skew) makes it infeasible to have a global
 clock.
 Avoiding the global clock is a tremendous advantage, especialy compare
 to power usage.
 Designing an Asynchronous NoC would solve the problem of bandwidth and
 the problem of routing one global clock.
\end_layout

\begin_layout Section
Design and Implementation
\end_layout

\begin_layout Subsection
Asynchronous TDMA Network-on-Chip
\begin_inset Marginal
status open

\begin_layout Plain Layout
Rasmus
\end_layout

\end_inset


\end_layout

\begin_layout Standard
We will design and implement an asyncronous TDMA Network-on-Chip, similar
 to the Æthereal NoC, designed by Philips.
 TDMA stands for Time Division Multiple Access, which means the communication
 resources are divided in time and split into sections allowing multiple
 data units to be routed simultainiously.
\end_layout

\begin_layout Standard
The Æthereal NoC is a statically scheduled NoC, where a compile-time schedule
 has been made that ensures no two data units are routed on the same link
 at once.
\end_layout

\begin_layout Standard
Dividing communication resources into timeslots, require synchronization
 of these resources, to make sure that no timeslots are dropped.
 In a synchronous NoC this synchronization is easily derived from the global
 clock.
 In our asynchronous implementation the synchronization is done by waiting
 for data units on all inputs of a node to be present, before routing them
 through the switch.
 Ensures that no data units are dropped and that the timeslots are transmitted
 in order.
 This synchronization does not mean that all links at all time will be transmitt
ing the same timeslot, but it means that each switch transmittes the same
 timeslots at once.
 Asynchronous circuits are elastic with respect to timing.
 In our NoC the elasticity means that constant phase differences between
 the transmission of flits in two neighboring switches as well as minor
 fluctuation in the propergation delays of links, can be absorbed by the
 network.
\end_layout

\begin_layout Subsection
\begin_inset CommandInset label
LatexCommand label
name "sub:Protocol"

\end_inset

Protocol
\begin_inset Marginal
status open

\begin_layout Plain Layout
Mark
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Our protocol is simplistic: Packets are statically source-routed using cut-throu
gh routing, with 1
\begin_inset space ~
\end_inset

flit being equal to 1
\begin_inset space ~
\end_inset

phit.
 Packets can however consist of an arbitrary number of flits.
 Delimitation of packets is indicated by the 
\emph on
Start-Of-Packet
\emph default
 (SOP) and 
\emph on
End-Of-Packet
\emph default
 (EOP) bit fields, as shown in figure
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "fig:flit_format"

\end_inset

.
 
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{centering}
\end_layout

\begin_layout Plain Layout


\backslash
begin{bytefield}{34}
\end_layout

\begin_layout Plain Layout

   
\backslash
bitheader[b]{0-33} 
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

   
\backslash
bitbox{1}{
\backslash
rotatebox{90}{
\backslash
tiny SOP}} &
\end_layout

\begin_layout Plain Layout

   
\backslash
bitbox{1}{
\backslash
rotatebox{90}{
\backslash
tiny EOP}} &
\end_layout

\begin_layout Plain Layout

   
\backslash
bitbox{32}{Payload}
\end_layout

\begin_layout Plain Layout

 
\backslash
end{bytefield}
\end_layout

\begin_layout Plain Layout


\backslash
par
\backslash
end{centering}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:flit_format"

\end_inset

Format of all flits.
 
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Since we are using cut-through source-routing, it is only possible to store
 the route in the first few flits of a packet -- the 
\emph on
header
\emph default
.
 In our case the header is only 1
\begin_inset space ~
\end_inset

flit long, and contains the full remaining route.
 It contains only what 
\emph on
remains
\emph default
 of the route, since previous routing-directions are shifted out for each
 hop made.
 As we will see later, this allows for simple routing-decision logic.
\end_layout

\begin_layout Standard
\align center
\begin_inset Float table
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="5" columns="3">
<features tabularvalignment="middle">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="left" valignment="top" width="0">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
SOP
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
EOP
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Type of flit
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\emph on
Empty space
\emph default
.
 Does not belong to a packet.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\emph on
Header
\emph default
.
 First flit of packet.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\emph on
Body
\emph default
.
 Contains payload.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\emph on
End body
\emph default
.
 Last flit of packet.
 Contains payload.
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Encoding of flit types.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
The first flit of a packet is the 
\emph on
header
\emph default
.
 
\end_layout

\begin_layout Standard
Bottom 2 LSbs of header determines the next hop
\begin_inset Note Note
status open

\begin_layout Plain Layout
better word than 
\begin_inset Quotes eld
\end_inset

hop
\begin_inset Quotes erd
\end_inset

?
\end_layout

\end_inset

.
 Shifted header + remaining flits of packet is routed to this next hop.
\end_layout

\begin_layout Standard
Maximum of (34-2)/2=16 hops can be encoded in the header.
 If the mesh is to be square and any resource should be able to communicte
 any other resource, this 16 hop limit, restricts us to 
\begin_inset Formula $9\times9$
\end_inset

 meshes
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
\begin_inset Formula $2(n-1)=16\iff n=9$
\end_inset

.
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
Header, body, empty space grey encoding.
 Packets must not have empty-spaces between flits; ie.
 a packets are delimited by headers and empty-spaces.
\end_layout

\begin_layout Standard
Route towards resource if going backwards
\end_layout

\begin_layout Subsection
Switch
\begin_inset Marginal
status open

\begin_layout Plain Layout
Madava
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Internal structure: Our switch consists of an routing unit (HPU) followed
 by a crossbar.
\end_layout

\begin_layout Standard
Idealized symbol of switch.
 
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
Insert overall block diagram of switch - similar to the phillips paper
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
HPU
\begin_inset Marginal
status open

\begin_layout Plain Layout
Mark
\end_layout

\end_inset


\end_layout

\begin_layout Standard
As mentioned in the protocol description, the entire route is contained
 in the header.
 All flits of the packet should be routed as specified by the next-hop field
 in the header.
 Hence the routing-logic has to:
\end_layout

\begin_layout Enumerate
Identify the header.
\end_layout

\begin_layout Enumerate
If a header is found:
\end_layout

\begin_deeper
\begin_layout Enumerate
Parse the header -- setting the crossbar according to next-hop field,
\end_layout

\begin_layout Enumerate
Update the route such that the next-next-hop will become the next-hop at
 the next switch.
\end_layout

\end_deeper
\begin_layout Enumerate
Keep crossbar-settings for all flits of the packet.
\end_layout

\begin_deeper
\begin_layout Enumerate
Reset settings upon receiving an empty-space.
\end_layout

\end_deeper
\begin_layout Enumerate
Leave non-header flits unaltered.
\end_layout

\begin_layout Standard
Since we assign special meaning to the header of each packet, our protocol
 is stateful.
 This makes the 
\emph on
header-parsing unit
\emph default
 the most complex part of our switch.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename Figures/hpu_top.pdf
	width 10cm

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:HPU"

\end_inset

Simplified Header-parsing unit.
 Resetting by empty-spaces not shown.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
The HPU speculatively computes the one-hot decoded 
\begin_inset Formula $select$
\end_inset

 signal for use in the crossbar-stage.
 When it has been determined that the flit is a header, 
\begin_inset Formula $select$
\end_inset

 is latched forward to the crossbar-stage.
 
\end_layout

\begin_layout Standard
Since the select latch is a simple latch, not a token-latch, we should be
 careful to not accidentally opening it.
\end_layout

\begin_layout Standard
Assume early scheme 
\end_layout

\begin_layout Standard
sel should be set before the processed flit is latched into the token-latch.
\end_layout

\begin_layout Standard
As previously described, the bottom 32 bits of the header is shifted by
 2 bits, forming the new header that is parsed by the next switch.
 
\end_layout

\begin_layout Standard
What we shift in is don't care, since 
\end_layout

\begin_layout Standard
Currently 00 is shifted in 
\end_layout

\begin_layout Standard
The current implementation of the switch shifts the header by 2 bits, shifting
 in 00.
 Since the last hop will route to the resource, these 2 bits are don't care
\end_layout

\begin_layout Standard
currently shifts 00 into the route of headers.
 
\end_layout

\begin_layout Subsubsection
Crossbar
\begin_inset Marginal
status open

\begin_layout Plain Layout
Rasmus
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The crossbar we have implemented is fully generic, and can be instantiated
 with a given number of channels (A channels is one input port and one output
 port), it should be noted that the crossbar is a fully connected network,
 thus it does not scale linearly.
 To simplify the logic, the select signal to the de-multiplexers is one-hot
 encoded.
 This results in a de-multiplexer that can be made from a number of parallel
 
\noun on
and
\noun default
 gates, the logic depth is only one 
\noun on
and
\noun default
 gate, making the de-multiplexer very fast.
\end_layout

\begin_layout Standard
Because of the property of the static routing protocol, only one phit is
 routed to one output port of a switch in each timeslot.
 The multiplexer can simply be implemented as a number of parallel 
\noun on
or
\noun default
 gates, also a logic depth of one 
\noun on
or
\noun default
 gate.
\end_layout

\begin_layout Paragraph
Synchronization of timeslots
\end_layout

\begin_layout Standard
Synchronization of the timeslots are done, by waiting for packets on all
 the input channels, when all input packets are ready they are transmitted
 to the output latches of the switch, C-elements are used to synchronize
 the request signals.
\end_layout

\begin_layout Subsubsection
Latches
\begin_inset Marginal
status open

\begin_layout Plain Layout
Mark
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Testbench
\begin_inset Marginal
status open

\begin_layout Plain Layout
Madava
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Contains assertions, like unit test
\end_layout

\begin_layout Standard
picture of route in mesh
\end_layout

\begin_layout Standard
Show figure of testbench
\end_layout

\begin_layout Standard
Explain heatmaps.
 They help in visualise dynamic behavior of the mesh network.
 
\end_layout

\begin_layout Standard
relative changes
\end_layout

\begin_layout Standard
cycle time and phase
\end_layout

\begin_layout Standard
Figures are disussed under the Performance characteristics section.
\end_layout

\begin_layout Section
Performance characteristics
\begin_inset Marginal
status open

\begin_layout Plain Layout
Rasmus
\end_layout

\end_inset


\end_layout

\begin_layout Standard
In this project we will concentrate on simulation, even though we have implement
ed the switch in synthesisable VHDL.
 The performance characteristics of our switch nodes will only be investigated
 through behavioral simulations, with the propergation delays we have specified.
 Therefore we can not give any real values for the characteristics.
\end_layout

\begin_layout Standard
What we can investigate is how the elasticity is able to cope with fluctuating
 propergation delays on links and how the network handles phase changes
 between nodes in the network.
\end_layout

\begin_layout Standard
The network 
\end_layout

\begin_layout Standard
Heatmap, what is it good for, what can it show? 
\end_layout

\begin_layout Standard
Experiments to find performance characteristics, which values have we measured?
 Compared to synchronous performance.
\end_layout

\begin_layout Standard
In an asynchronous system the speed of links can vary, because the system
 is running with average performance instead of worst-case performance as
 synchronous systems.
 We have made an animated gif file for visualising the spreading of a performanc
e lowering in one link.
\end_layout

\begin_layout Standard
Explaining the permanent phase change in the steadystate - even after delay
 has gone.
 Mesosynchronous.
 Buffer space in latches.
 
\end_layout

\begin_layout Section
Discussion
\begin_inset Marginal
status open

\begin_layout Plain Layout
Rasmus
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The asynchronous fibonaci circuit can run in an FPGA, this shows the basic
 primetives work (Latches, C-elements, ...) The only thing preventing our NoC
 from runing an an FPGA is the matched delays.
 Everything is synthesizable.
 Matched delays could be avoided by using dual-rail instead bundled data.
 
\end_layout

\begin_layout Standard
While we have focused purely on the interconnect, for a full NoC implementation
 we would also require Network Interfaces at every resource.
 Routing tables and timeslot information.
\end_layout

\begin_layout Standard
Timeslotting is higher level protocol.
\end_layout

\begin_layout Standard
To determine in which timeslot the NI is in, a simple counter is used to
 count handshakes.
\end_layout

\begin_layout Standard
Definition of a flit is up to the NI.
 Our switch works a phit-level, and the NI could decide that 1 flit is 2
 phits.
\end_layout

\begin_layout Standard
resetting
\end_layout

\begin_layout Standard
our switch implementation supports arbitrary length of flits in a packet.
\end_layout

\begin_layout Standard
the larger the packet, the less overhead.
\end_layout

\begin_layout Standard
Our main design decision has been to minimize swtich complexity, at a cost
 of NI complexity.
 In fact the swtich can't be any simpler.
\end_layout

\begin_layout Section
Conclusion
\begin_inset Marginal
status open

\begin_layout Plain Layout
Rasmus
\end_layout

\end_inset


\end_layout

\begin_layout Standard
We have implemented a working asynchrounous TDMA network-on-chip.
 It works.
 
\end_layout

\begin_layout Standard
We simulated
\end_layout

\begin_layout Standard
Further investigate how phase changes perma.
\end_layout

\begin_layout Standard
Injecting delays, had an expected 
\end_layout

\begin_layout Standard
Cycle times are as expected
\end_layout

\begin_layout Standard
Interesting observation that requires further investigation.
\end_layout

\begin_layout Standard
Phase is not as expected, but has no performance impact.
\end_layout

\begin_layout Standard
Stochastic delays.
\end_layout

\end_body
\end_document
